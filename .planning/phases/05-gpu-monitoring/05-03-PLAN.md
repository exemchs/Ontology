---
phase: 05-gpu-monitoring
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/components/gpu/GpuHeatmap.tsx
  - src/components/gpu/GpuRidgeline.tsx
autonomous: true
requirements: [GPU-04, GPU-05]

must_haves:
  truths:
    - "Heatmap renders a GPU x Time matrix with 4 rows (GPUs) and 24 columns (time intervals)"
    - "Heatmap uses sequential color scale (yellow-orange-red) to encode utilization 0-100%"
    - "Hovering a heatmap cell shows tooltip with GPU name, time, and utilization value"
    - "Ridgeline chart shows 4 GPU density curves stacked vertically with overlap"
    - "Ridgeline uses kernel density estimation to smooth utilization distributions"
    - "Toggling the switch in GpuHeatmapRidgelineToggle swaps between heatmap and ridgeline views"
    - "Both charts respond to container resize and clean up SVG on unmount"
  artifacts:
    - path: "src/components/gpu/GpuHeatmap.tsx"
      provides: "D3 heatmap with sequential color scale and hover tooltips"
      min_lines: 80
    - path: "src/components/gpu/GpuRidgeline.tsx"
      provides: "D3 ridgeline chart with KDE density estimation"
      min_lines: 100
  key_links:
    - from: "src/components/gpu/GpuHeatmap.tsx"
      to: "d3-scale-chromatic"
      via: "interpolateYlOrRd for sequential color"
      pattern: "interpolateYlOrRd"
    - from: "src/components/gpu/GpuRidgeline.tsx"
      to: "d3-shape"
      via: "area generator for density fill"
      pattern: "import.*area.*from.*d3-shape"
    - from: "src/components/gpu/GpuHeatmap.tsx"
      to: "@/components/charts/shared/chart-utils"
      via: "cleanupD3Svg, createDebouncedResizeObserver"
      pattern: "import.*cleanupD3Svg.*from.*chart-utils"
    - from: "src/components/gpu/GpuRidgeline.tsx"
      to: "@/components/charts/shared/chart-utils"
      via: "cleanupD3Svg, createDebouncedResizeObserver"
      pattern: "import.*cleanupD3Svg.*from.*chart-utils"
---

<objective>
Implement the D3 Heatmap (GPU-04) and D3 Ridgeline (GPU-05) chart components. These two charts share the same container area via the toggle switch created in Plan 01. The heatmap shows GPU utilization as a color-coded matrix; the ridgeline shows utilization density distributions using kernel density estimation.

Purpose: Deliver the two most visually distinctive D3 chart types in the GPU monitoring page. The heatmap provides at-a-glance utilization patterns over time, while the ridgeline reveals utilization distribution shapes per GPU.
Output: Two working D3 chart components that swap via the existing toggle container, with theme-aware colors, responsive sizing, and tooltips.
</objective>

<execution_context>
@/Users/chs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gpu-monitoring/05-CONTEXT.md
@.planning/phases/05-gpu-monitoring/05-RESEARCH.md
@.planning/phases/05-gpu-monitoring/05-01-SUMMARY.md
@src/components/charts/shared/chart-utils.ts
@src/components/charts/shared/chart-theme.ts
@src/components/charts/shared/chart-tooltip.ts
@src/components/charts/shared/ChartSkeleton.tsx
@src/data/gpu-data.ts
@src/components/gpu/GpuHeatmapRidgelineToggle.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: D3 Heatmap Chart</name>
  <files>src/components/gpu/GpuHeatmap.tsx</files>
  <action>
Replace the ChartSkeleton stub in GpuHeatmap.tsx with a full D3 heatmap implementation.

**Component structure:**
- `"use client"` component
- Props: `{ data: GpuHeatmapCell[] }` (imported from `@/data/gpu-data`)
- State: `isClient: boolean`
- Ref: `containerRef` for D3 SVG container

**Layout:**
- No outer Card (the parent GpuHeatmapRidgelineToggle already provides the Card wrapper)
- Chart container div: `className="w-full h-[250px]"` with `data-testid="gpu-heatmap"`

**D3 rendering:**
1. Guard + colors + tooltip + cleanup (standard pattern)
2. Margins: `{ top: 20, right: 80, bottom: 40, left: 60 }` — right margin for color legend
3. Extract unique GPU names: `["GPU-0", "GPU-1", "GPU-2", "GPU-3"]` (from data)
4. Extract unique time indices: `range(0, 24)` (from data)

**Scales:**
- `xScale`: `d3.scaleBand<number>()` domain=time indices, range=[0, innerW], padding(0.02)
- `yScale`: `d3.scaleBand<string>()` domain=GPU names, range=[0, innerH], padding(0.05) — **CRITICAL:** use small padding (0.05) to avoid thin cells with only 4 rows
- `colorScale`: `d3.scaleSequential(d3.interpolateYlOrRd)` domain=[0, 100] — per user decision: sequential color scale for utilization

**Cells:**
- `g.selectAll("rect").data(data).join("rect")`
- x: `xScale(d.timeIndex)!`
- y: `yScale(d.gpuName)!`
- width: `xScale.bandwidth()`
- height: `yScale.bandwidth()`
- fill: `colorScale(d.utilization)`
- rx: 2 (rounded corners)
- On mouseover: show tooltip with `<strong>${d.gpuName}</strong><br/>Time: ${format time}<br/>Utilization: ${d.utilization}%`
- On mouseout: hide tooltip

**Axes:**
- X-axis (bottom): Show time labels using `d3.timeFormat("%H:%M")` for every 4th tick to avoid crowding
- Y-axis (left): GPU names

**Color Legend (right side):**
- Draw a vertical gradient bar (using defs > linearGradient) showing the YlOrRd color scale
- Label: "0%" at bottom, "100%" at top
- Position in the right margin area

**Style axis text and lines with theme colors from `getChartColors()`.**

**Cleanup:** observer.disconnect(), tooltip.destroy(), cleanupD3Svg().
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify D3 imports: `grep "interpolateYlOrRd" src/components/gpu/GpuHeatmap.tsx` confirms the sequential color scale import. Verify `wc -l src/components/gpu/GpuHeatmap.tsx` is at least 80 lines.</verify>
  <done>Heatmap renders 4 GPU rows x 24 time columns with YlOrRd sequential color fill. Cells have rounded corners. Tooltip shows GPU/time/utilization on hover. Color legend shows scale 0-100%. Responsive resizing and proper cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: D3 Ridgeline Chart with Kernel Density Estimation</name>
  <files>src/components/gpu/GpuRidgeline.tsx</files>
  <action>
Replace the ChartSkeleton stub in GpuRidgeline.tsx with a full D3 ridgeline chart using KDE.

**Component structure:**
- `"use client"` component
- Props: `{ data: GpuTimeSeries[] }` (imported from `@/data/gpu-data`)
- State: `isClient: boolean`
- Ref: `containerRef` for D3 SVG container

**Layout:**
- No outer Card (parent GpuHeatmapRidgelineToggle provides Card wrapper)
- Chart container div: `className="w-full h-[250px]"` with `data-testid="gpu-ridgeline"`

**KDE utility functions (define inside the component file, not exported):**

```typescript
function kernelDensityEstimator(
  kernel: (v: number) => number,
  X: number[]
) {
  return function (V: number[]) {
    return X.map((x) => [x, d3.mean(V, (v) => kernel(x - v)) ?? 0] as [number, number]);
  };
}

function kernelEpanechnikov(k: number) {
  return function (v: number) {
    v = v / k;
    return Math.abs(v) <= 1 ? (0.75 * (1 - v * v)) / k : 0;
  };
}
```

**D3 rendering:**
1. Guard + colors + tooltip + cleanup (standard pattern)
2. Margins: `{ top: 20, right: 20, bottom: 40, left: 60 }`
3. Extract utilization data per GPU: filter `data` to metric === "utilization", then for each GPU collect `series.data.map(d => d.value)`
4. GPU names: `["GPU-0", "GPU-1", "GPU-2", "GPU-3"]`

**Scales:**
- `xScale`: `d3.scaleLinear()` domain=[0, 100] (utilization range), range=[0, innerW]
- `yScale`: `d3.scaleBand<string>()` domain=GPU names, range=[0, innerH], paddingInner(0.4) — larger padding for ridgeline overlap

**KDE computation:**
- Create KDE estimator with bandwidth=7 and 50 evaluation points across [0, 100]: `const kde = kernelDensityEstimator(kernelEpanechnikov(7), xScale.ticks(50))`
- For each GPU, compute density: `kde(gpuUtilValues)`
- **CRITICAL:** Clamp KDE evaluation domain to [0, 100] — the `xScale.ticks(50)` naturally stays in range since the domain is [0, 100]

**Density scale:**
- Find max density across all GPUs: `d3.max(allDensities.flat().map(d => d[1]))`
- `densityScale`: `d3.scaleLinear()` domain=[0, maxDensity], range=[0, -yScale.bandwidth() * 1.5] — negative range draws upward from baseline

**Area generator:**
- `d3.area<[number, number]>().x(d => xScale(d[0])).y0(0).y1(d => densityScale(d[1])).curve(d3.curveBasis)`

**Drawing ridgelines:**
- For each GPU (index i):
  - Compute yOffset: `yScale(gpuName)! + yScale.bandwidth()` (baseline at bottom of band)
  - Append a `<path>` with `transform: translate(0, ${yOffset})`
  - Fill: `var(--chart-${i + 1})` with `fill-opacity: 0.6`
  - Stroke: `var(--chart-${i + 1})` with `stroke-width: 1.5`
  - datum: the KDE density array for this GPU

**GPU labels:**
- Add text labels on the left (inside the y-axis area) for each GPU name, vertically centered in each band

**X-axis:**
- Bottom axis with label "Utilization %" and ticks at 0, 25, 50, 75, 100

**Tooltip:**
- On mouseover of a ridgeline path: show GPU name
- Optional: show peak utilization value

**Cleanup:** observer.disconnect(), tooltip.destroy(), cleanupD3Svg().

**Performance note:** The KDE computation with 4 GPUs x 24 points x 50 evaluation points is lightweight. No memoization needed for this data size, but compute density outside the D3 drawing block and pass it in to keep the draw function focused on rendering.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify KDE functions exist: `grep "kernelDensityEstimator" src/components/gpu/GpuRidgeline.tsx`. Verify `grep "curveBasis" src/components/gpu/GpuRidgeline.tsx` confirms smooth curve. Verify `wc -l src/components/gpu/GpuRidgeline.tsx` is at least 100 lines.</verify>
  <done>Ridgeline chart renders 4 GPU density curves with vertical offset and overlap. KDE produces smooth density shapes from utilization time series. Fill is semi-transparent with chart series colors. X-axis shows utilization 0-100%. Responsive resizing and proper cleanup.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds with /monitoring/gpu route
3. GpuHeatmap.tsx uses d3.scaleSequential(interpolateYlOrRd) for color encoding
4. GpuRidgeline.tsx contains kernelDensityEstimator and kernelEpanechnikov functions
5. Both components use established patterns: cleanupD3Svg, createDebouncedResizeObserver, getChartColors, createTooltip
6. Both components handle SSR with isClient guard and ChartSkeleton fallback
7. Toggling the switch in GpuHeatmapRidgelineToggle swaps between the two charts
</verification>

<success_criteria>
- Heatmap: 4x24 matrix with YlOrRd gradient, hover tooltip showing GPU/time/value, color legend
- Ridgeline: 4 stacked density curves with KDE smoothing, semi-transparent fills, chart series colors
- Toggle switch swaps between heatmap and ridgeline without errors
- Both charts resize on container change and clean up D3 elements on unmount
- No TypeScript errors, build passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-gpu-monitoring/05-03-SUMMARY.md`
</output>
