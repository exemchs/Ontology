---
phase: 04-dgraph-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/dgraph-data.ts
  - src/components/dgraph/ClusterTopology.tsx
autonomous: true
requirements: [DGRP-01, DGRP-02, DGRP-03]

must_haves:
  truths:
    - "12 nodes render as circles in an SVG with force-directed layout that stabilizes within 3 seconds"
    - "Clicking Force/Radial toggle smoothly transitions node positions between layouts"
    - "Node circles have colored status rings (green=healthy, amber=warning, red=error) with pulse animation on warning/error"
    - "Small particle circles animate along link lines representing data flow, togglable via ON/OFF switch"
    - "Nodes can be dragged to new positions and the canvas supports zoom/pan"
  artifacts:
    - path: "src/data/dgraph-data.ts"
      provides: "getDgraphEvents() function + qps field in node data"
      contains: "getDgraphEvents"
    - path: "src/components/dgraph/ClusterTopology.tsx"
      provides: "Force/Radial topology with particles, status rings, drag, zoom"
      min_lines: 200
  key_links:
    - from: "src/components/dgraph/ClusterTopology.tsx"
      to: "src/data/dgraph-data.ts"
      via: "getDgraphNodes(), getDgraphLinks() imports"
      pattern: "getDgraphNodes|getDgraphLinks"
    - from: "src/components/dgraph/ClusterTopology.tsx"
      to: "src/components/charts/shared/chart-theme.ts"
      via: "getChartColors() for resolved CSS variable colors"
      pattern: "getChartColors"
    - from: "src/components/dgraph/ClusterTopology.tsx"
      to: "src/components/charts/shared/chart-utils.ts"
      via: "cleanupD3Svg() for useEffect cleanup"
      pattern: "cleanupD3Svg"
---

<objective>
Build the D3 force simulation cluster topology -- the highest-risk component in the entire project. This single SVG renders 12 Dgraph nodes with Force/Radial layout toggle, status rings with pulse animation, particle data-flow animation on links, and drag/zoom interactivity.

Purpose: This is the centerpiece visualization of the DGraph Monitoring page. Force simulation lifecycle management in React is the core technical risk identified in research.
Output: ClusterTopology.tsx component + dgraph-data.ts enhancements
</objective>

<execution_context>
@/Users/chs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dgraph-monitoring/04-RESEARCH.md
@.planning/phases/04-dgraph-monitoring/04-CONTEXT.md
@.planning/phases/01-foundation-data-layer/01-03-SUMMARY.md
@.planning/phases/01-foundation-data-layer/01-04-SUMMARY.md
@src/types/index.ts
@src/data/dgraph-data.ts
@src/components/charts/shared/chart-utils.ts
@src/components/charts/shared/chart-theme.ts
@src/components/charts/shared/chart-tooltip.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend dgraph-data.ts with events and QPS data</name>
  <files>src/data/dgraph-data.ts</files>
  <action>
Add two new exports to the existing `src/data/dgraph-data.ts` file:

1. **Add `qps` field to `NodeSeed` interface and seed data:**
   - Add `qps: number` to the `NodeSeed` interface
   - Add QPS values to each of the 12 node seeds: Zero nodes ~200-400 (coordinator traffic), Alpha nodes ~800-1800 (data serving), Compute nodes ~1200-2500 (heavy query load). The `error` node (sks-compute-03) should have very low QPS (~50) indicating degraded state.
   - Map `qps` through `getDgraphNodes()` return with jitter applied: `qps: Math.round(addJitter(seed.qps, 8))`
   - Update the return type: since `ClusterNode` in types/index.ts does not have `qps`, either extend the type OR create a local `DgraphNode` interface that extends `ClusterNode` with `qps: number`. Prefer the local extension approach: `export interface DgraphNode extends ClusterNode { qps: number }` and change `getDgraphNodes()` return type to `DgraphNode[]`.

2. **Add `getDgraphEvents()` function:**
   - Create `DgraphEvent` interface: `{ id: string; nodeId: number; nodeName: string; severity: "error" | "warning" | "info"; title: string; message: string; timestamp: string }`
   - Export function `getDgraphEvents(): DgraphEvent[]` returning 10 hardcoded events with realistic Dgraph cluster messages. Examples:
     - error: "sks-compute-03 memory usage exceeded 90% threshold"
     - warning: "sks-alpha-03 high CPU utilization detected (78.9%)"
     - info: "Raft consensus completed for Group 1"
     - info: "Schema update applied successfully"
     - warning: "Slow query detected: 450ms on sks-alpha-06"
   - Timestamps should be recent (within last 2 hours), generated relative to `new Date()` so they feel current.
   - Sort events by timestamp descending (newest first).

Do NOT modify `src/types/index.ts` -- keep the `DgraphNode` and `DgraphEvent` types local to `dgraph-data.ts`.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm type-checking passes. Verify exports exist: the file should export `DgraphNode`, `DgraphEvent`, `getDgraphNodes`, `getDgraphLinks`, `getDgraphShards`, `getDgraphQueries`, `getDgraphEvents`.</verify>
  <done>getDgraphNodes() returns DgraphNode[] with qps field. getDgraphEvents() returns 10 events with severity/timestamp. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Build ClusterTopology force simulation component</name>
  <files>src/components/dgraph/ClusterTopology.tsx</files>
  <action>
Create `src/components/dgraph/ClusterTopology.tsx` as a `"use client"` React component implementing the D3 force-directed cluster topology.

**Component interface:**
```typescript
interface ClusterTopologyProps {
  onNodeClick?: (node: DgraphNode, screenX: number, screenY: number) => void;
  className?: string;
}
```
The `onNodeClick` callback passes the node data and screen coordinates so the parent can position a popover (built in Plan 04-03).

**Internal D3 datum types (local to this file):**
```typescript
interface NodeDatum extends d3.SimulationNodeDatum {
  id: number;
  node: DgraphNode; // full node data
}
interface LinkDatum extends d3.SimulationLinkDatum<NodeDatum> {
  type: "zero-alpha" | "alpha-alpha" | "zero-zero";
}
interface Particle {
  link: LinkDatum;
  offset: number;
  speed: number;
}
```

**State management (React vs Refs):**
- `useRef`: svgRef (SVGSVGElement), simulationRef (d3.Simulation), particlesEnabledRef (boolean), animFrameRef (number), destroyedRef (boolean)
- `useState`: `layout` ("force" | "radial"), `particlesEnabled` (boolean, default true)
- Sync `particlesEnabled` state to `particlesEnabledRef.current` so the rAF loop reads the latest value without re-running the effect.

**Layout: Force mode (default):**
- `forceLink`: links with `.id(d => d.id)`, distance 100
- `forceManyBody`: strength -300
- `forceCenter`: center of SVG (width/2, height/2)
- `forceCollide`: radius + 10 to prevent overlap

**Layout: Radial mode:**
- Remove `forceCenter`, set to null
- Add `forceRadial` with radius function: zero nodes -> 0 (center), alpha nodes with "alpha" prefix -> 120, compute nodes -> 200
- `forceManyBody`: strength -50 (weaker)
- `forceLink`: distance 60, strength 0.1
- `forceRadial` strength: 0.8

**Toggle between layouts:** Call `setForceLayout(sim)` or `setRadialLayout(sim)` which swap forces and call `simulation.alpha(0.3).alphaTarget(0).restart()` for smooth transition. Do NOT destroy/recreate the simulation.

**SVG structure (inside a `<g>` container transformed by zoom):**
1. Links layer: `<line>` elements for each link, styled by type (zero-zero: dashed, zero-alpha: solid, alpha-alpha: lighter opacity)
2. Particles layer: `<circle>` elements (r=2, fill chart1 color with 0.7 opacity) animated via rAF
3. Nodes layer: For each node, a `<g>` group containing:
   - Status ring: `<circle>` with r=NODE_RADIUS+4, no fill, stroke color from `getStatusColor(node.status)` using CSS vars (healthy: `var(--color-text-success)`, warning: `var(--color-text-warning)`, error: `var(--color-text-critical)`). Warning/error nodes get CSS class `pulse-ring`.
   - Node circle: `<circle>` with r=NODE_RADIUS (zero=20, alpha=26), fill from chart colors (zero=chart1, alpha=chart2)
   - Label: `<text>` showing short name (e.g., "Z1", "A3", "C2") centered inside the circle, font-size 10, fill white

**Pulse animation (CSS, defined in component or added to globals.css):**
Add a `<style>` element inside the SVG or use D3 to inject a CSS animation:
```css
@keyframes pulse-ring {
  0%, 100% { opacity: 1; stroke-width: 3px; }
  50% { opacity: 0.4; stroke-width: 5px; }
}
.pulse-ring { animation: pulse-ring 2s ease-in-out infinite; }
```

**Particle animation (separate rAF loop):**
- Initialize 2-3 particles per link (staggered offsets: 0, 0.33, 0.66)
- Zero-zero links get 3 particles (higher traffic), others get 2
- Speed: 0.003-0.005 per frame (adjusts by link type)
- Each frame: increment offset, wrap at 1.0, interpolate cx/cy from source to target positions
- Check `particlesEnabledRef.current` each frame; if false, hide particle group (display none) but keep the loop running for instant toggle-on
- Check `destroyedRef.current` to stop the loop on unmount

**Drag behavior (d3.drag):**
- On start: `simulation.alphaTarget(0.3).restart()`, set `d.fx = d.x; d.fy = d.y`
- On drag: `d.fx = event.x; d.fy = event.y`
- On end: `simulation.alphaTarget(0)`, set `d.fx = null; d.fy = null`

**Zoom behavior (d3.zoom):**
- scaleExtent [0.3, 4]
- On zoom: apply transform to the container `<g>`
- Close any open popover when zoom/pan starts (call `onNodeClick?.(null as any, 0, 0)` or better: expose a separate `onBackgroundClick` or just let the parent handle it)

**Node click handler:**
- On node circle click: `event.stopPropagation()`, calculate screen position using `svgRef.getBoundingClientRect()` + `d3.zoomTransform()`, call `onNodeClick(d.node, screenX, screenY)`
- On SVG background click: call `onNodeClick?.(null as any, 0, 0)` to signal popover close

**Resize handling:**
- Use `createDebouncedResizeObserver` from chart-utils to watch the container div
- On resize: update simulation center force and forceRadial center, reheat with alpha(0.1)

**Theme handling:**
- Call `getChartColors()` inside the main useEffect to get resolved colors
- Apply colors to links, nodes, labels, background

**Cleanup (useEffect return):**
- Set `destroyedRef.current = true` (stops particle rAF loop)
- Cancel any pending rAF with `cancelAnimationFrame(animFrameRef.current)`
- Call `simulation.stop()`
- Call `cleanupD3Svg(svgRef.current)`
- Disconnect ResizeObserver

**JSX structure:**
```tsx
<div ref={containerRef} className={cn("relative w-full h-full min-h-[400px]", className)}>
  {/* Layout toggle */}
  <div className="absolute top-3 left-3 z-10 flex items-center gap-2">
    <Tabs value={layout} onValueChange={(v) => setLayout(v as "force" | "radial")}>
      <TabsList className="h-8">
        <TabsTrigger value="force" className="text-xs px-3">Force</TabsTrigger>
        <TabsTrigger value="radial" className="text-xs px-3">Radial</TabsTrigger>
      </TabsList>
    </Tabs>
  </div>
  {/* Particle toggle */}
  <div className="absolute top-3 right-3 z-10 flex items-center gap-2">
    <Label htmlFor="particles" className="text-xs text-muted-foreground">Particles</Label>
    <Switch id="particles" checked={particlesEnabled} onCheckedChange={setParticlesEnabled} />
  </div>
  {/* SVG canvas */}
  <svg ref={svgRef} className="w-full h-full" data-testid="cluster-topology" />
</div>
```

Import shadcn components: `Tabs`, `TabsList`, `TabsTrigger` from `@/components/ui/tabs`, `Switch` from `@/components/ui/switch`, `Label` from `@/components/ui/label`.

Import data: `getDgraphNodes`, `getDgraphLinks`, `DgraphNode` from `@/data/dgraph-data`.
Import utils: `cleanupD3Svg`, `createDebouncedResizeObserver` from `@/components/charts/shared/chart-utils`, `getChartColors` from `@/components/charts/shared/chart-theme`.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Verify file exists and has the core patterns: `forceSimulation`, `d3.drag`, `d3.zoom`, `requestAnimationFrame`, `pulse-ring`, `cleanupD3Svg`.</verify>
  <done>ClusterTopology renders 12 nodes in Force layout, toggles to Radial smoothly, shows status rings with pulse animation on warning/error nodes, animates particles along links with ON/OFF toggle, supports node drag and canvas zoom/pan, calls onNodeClick with screen coordinates, cleans up on unmount.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. ClusterTopology.tsx exists with `forceSimulation`, `d3.drag`, `d3.zoom`, `requestAnimationFrame` patterns
4. dgraph-data.ts exports `getDgraphEvents()` and `DgraphNode` with `qps` field
5. Status ring uses CSS variable references for theme-aware colors
6. Cleanup pattern: `simulation.stop()` + `cancelAnimationFrame` + `cleanupD3Svg` + `destroyedRef`
</verification>

<success_criteria>
- Force simulation renders 12 nodes and stabilizes within 3 seconds
- Force/Radial toggle transitions smoothly (alpha 0.3, no teleporting)
- Status rings: green (healthy), amber (warning), red (error) with pulse on non-healthy
- Particles animate along links independently of simulation tick
- Particle toggle immediately shows/hides particles
- Node drag works without triggering canvas pan
- Zoom/pan works on empty canvas area
- onNodeClick fires with screen coordinates for popover positioning
- Full cleanup on unmount (no memory leaks)
</success_criteria>

<output>
After completion, create `.planning/phases/04-dgraph-monitoring/04-01-SUMMARY.md`
</output>
