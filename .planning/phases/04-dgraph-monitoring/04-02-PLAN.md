---
phase: 04-dgraph-monitoring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/dgraph/QueryScatterPlot.tsx
  - src/components/dgraph/ShardBarChart.tsx
autonomous: true
requirements: [DGRP-05, DGRP-06]

must_haves:
  truths:
    - "50 query points render as colored dots on a Latency x Throughput scatter plot with GraphQL/DQL distinguished by color"
    - "User can brush-select a rectangular region on the scatter plot to filter visible queries"
    - "Clearing the brush selection resets to show all queries"
    - "Shard bar chart shows 3 groups with grouped bars colored by shard name using chart series colors"
    - "Both charts respond to dark/light theme changes and resize responsively"
  artifacts:
    - path: "src/components/dgraph/QueryScatterPlot.tsx"
      provides: "Brushable scatter plot for query latency vs throughput"
      min_lines: 100
    - path: "src/components/dgraph/ShardBarChart.tsx"
      provides: "Grouped bar chart for shard distribution"
      min_lines: 80
  key_links:
    - from: "src/components/dgraph/QueryScatterPlot.tsx"
      to: "src/data/dgraph-data.ts"
      via: "getDgraphQueries() import"
      pattern: "getDgraphQueries"
    - from: "src/components/dgraph/ShardBarChart.tsx"
      to: "src/data/dgraph-data.ts"
      via: "getDgraphShards() import"
      pattern: "getDgraphShards"
    - from: "src/components/dgraph/QueryScatterPlot.tsx"
      to: "src/components/charts/shared/chart-theme.ts"
      via: "getChartColors() for resolved colors"
      pattern: "getChartColors"
    - from: "src/components/dgraph/ShardBarChart.tsx"
      to: "src/components/charts/shared/chart-theme.ts"
      via: "getChartColors() for bar colors"
      pattern: "getChartColors"
---

<objective>
Build two independent D3 charts for the DGraph Monitoring page: a brushable query scatter plot and a grouped shard bar chart. These are standard D3 chart patterns (not force simulation) that can be built in parallel with Plan 04-01.

Purpose: Provide query performance analysis (scatter) and data distribution insight (shard bars) alongside the topology view.
Output: Two chart components ready for page assembly in Plan 04-03.
</objective>

<execution_context>
@/Users/chs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-dgraph-monitoring/04-RESEARCH.md
@.planning/phases/01-foundation-data-layer/01-03-SUMMARY.md
@src/data/dgraph-data.ts
@src/components/charts/shared/chart-utils.ts
@src/components/charts/shared/chart-theme.ts
@src/components/charts/shared/chart-tooltip.ts
@src/components/charts/shared/ChartSkeleton.tsx
@src/components/charts/shared/ChartEmpty.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build QueryScatterPlot with brush selection</name>
  <files>src/components/dgraph/QueryScatterPlot.tsx</files>
  <action>
Create `src/components/dgraph/QueryScatterPlot.tsx` as a `"use client"` component.

**Component interface:**
```typescript
interface QueryScatterPlotProps {
  className?: string;
}
```

**Data:** Call `getDgraphQueries()` from `@/data/dgraph-data` which returns `DgraphQueryPoint[]` with `{ id, latency, throughput, type }`. 50 points, type is "graphql" or "dql".

**State:**
- `useState` for `filteredCount: number | null` (null = no brush active, number = count of selected points)
- Use `useRef` for svgRef, containerRef, destroyedRef

**Scales:**
- X: `d3.scaleLinear()` for latency (ms), domain from data extent with nice()
- Y: `d3.scaleLinear()` for throughput (queries/sec), domain from data extent with nice()
- Color: GraphQL dots use chart1 (blue), DQL dots use chart2 (emerald)

**Margins:** `{ top: 20, right: 20, bottom: 40, left: 50 }`

**Rendering (in useEffect):**
1. Clear SVG with `cleanupD3Svg`
2. Resolve colors with `getChartColors()`
3. Create SVG with viewBox for responsiveness, append `<g>` for margin transform
4. Draw X axis at bottom with label "Latency (ms)"
5. Draw Y axis at left with label "Throughput (q/s)", format ticks with `formatNumber`
6. Style axes: use `colors.axisLine` for domain, `colors.tickLine` for ticks, `colors.text` for labels (font-size 11)
7. Draw dots: `<circle>` for each query point, r=5, fill by type (graphql=chart1, dql=chart2), opacity 0.7, stroke same color at opacity 1
8. Add tooltip on hover using `createTooltip()`: show id, latency (ms), throughput (q/s), type
9. Add D3 brush overlay

**Brush implementation (d3.brush):**
- Extent: `[[margin.left, margin.top], [width - margin.right, height - margin.bottom]]`
- On "brush" event (live feedback): highlight dots inside selection (full opacity), dim dots outside (opacity 0.2)
- On "end" event: if selection is null (click without drag), reset all dots to original opacity. If selection exists, calculate filtered count and update state. If selection is very small (<5px in both dimensions), treat as click-to-clear.
- Brush overlay should be behind dots so dots remain hoverable. Layer order: axes -> brush -> dots. Or: use `pointer-events: all` on dots above the brush overlay.
- Style the brush selection rectangle: fill with chart1 at 0.08 opacity, stroke with chart1 at 0.3 opacity.

**Legend (rendered above chart):**
- Small colored circles + labels: "GraphQL" (chart1), "DQL" (chart2)
- If brush active, show: "Selected: {filteredCount} / 50 queries"

**Resize handling:**
- Use `createDebouncedResizeObserver` on containerRef
- On resize: re-render the entire chart (call the render function again)

**Cleanup:**
- `cleanupD3Svg`, destroy tooltip, disconnect observer, set destroyedRef

**JSX:**
```tsx
<div ref={containerRef} className={cn("w-full", className)}>
  <div className="flex items-center justify-between mb-2">
    <div className="flex items-center gap-4 text-xs text-muted-foreground">
      <span className="flex items-center gap-1.5">
        <span className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "var(--chart-1)" }} />
        GraphQL
      </span>
      <span className="flex items-center gap-1.5">
        <span className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "var(--chart-2)" }} />
        DQL
      </span>
    </div>
    {filteredCount !== null && (
      <span className="text-xs text-muted-foreground">
        Selected: {filteredCount} / 50
      </span>
    )}
  </div>
  <svg ref={svgRef} className="w-full" style={{ height: 300 }} data-testid="query-scatter-plot" />
</div>
```

Import: `getDgraphQueries`, `DgraphQueryPoint` from `@/data/dgraph-data`, chart shared utils, `cn` from `@/lib/utils`, `d3` (or specific modules).
  </action>
  <verify>Run `npx tsc --noEmit`. Verify file contains `d3.brush`, `scaleLinear`, axis rendering, and tooltip creation.</verify>
  <done>QueryScatterPlot renders 50 dots colored by query type, brush selection highlights/dims dots and shows selection count, clearing brush resets all dots, axes labeled, tooltip on hover, responsive resize.</done>
</task>

<task type="auto">
  <name>Task 2: Build ShardBarChart grouped bar chart</name>
  <files>src/components/dgraph/ShardBarChart.tsx</files>
  <action>
Create `src/components/dgraph/ShardBarChart.tsx` as a `"use client"` component.

**Component interface:**
```typescript
interface ShardBarChartProps {
  className?: string;
}
```

**Data:** Call `getDgraphShards()` from `@/data/dgraph-data` which returns `DgraphShard[]` with `{ group, shards: { name, size }[] }`. 3 groups, 4-5 shards each.

**Scales:**
- X outer: `d3.scaleBand()` for group names ("Group 1", "Group 2", "Group 3"), paddingInner 0.2
- X inner: `d3.scaleBand()` for shard names within each group, padding 0.05
- Y: `d3.scaleLinear()` for shard sizes, domain [0, max size] with nice()
- Color: `d3.scaleOrdinal()` mapping shard names to chart series colors (chart1 through chart8). Collect all unique shard names across groups for the domain.

**Margins:** `{ top: 20, right: 20, bottom: 40, left: 60 }`

**Rendering (in useEffect):**
1. Clear SVG with `cleanupD3Svg`
2. Resolve colors with `getChartColors()`
3. Create SVG, append margin group
4. Draw X axis at bottom (group names), style with theme colors
5. Draw Y axis at left, format ticks with `formatNumber` from chart-utils, style with theme colors
6. For each group, draw bars at `x0(group) + x1(shardName)` position, width `x1.bandwidth()`, height from y scale, fill from color scale
7. Add tooltip on bar hover: show shard name, group, size formatted with `formatNumber`
8. Optional: Add subtle hover effect (increase opacity or add stroke on mouseover)

**Legend (rendered below or above chart):**
- Horizontal row of shard names with colored squares. Use the unique shard names from the color scale domain.
- Style: flex wrap, gap-3, text-xs, text-muted-foreground

**Resize handling:**
- Use `createDebouncedResizeObserver`, re-render on resize

**Cleanup:**
- `cleanupD3Svg`, destroy tooltip, disconnect observer

**JSX:**
```tsx
<div ref={containerRef} className={cn("w-full", className)}>
  <svg ref={svgRef} className="w-full" style={{ height: 280 }} data-testid="shard-bar-chart" />
  <div className="flex flex-wrap items-center justify-center gap-3 mt-2 text-xs text-muted-foreground">
    {uniqueShardNames.map(name => (
      <span key={name} className="flex items-center gap-1.5">
        <span className="w-2.5 h-2.5 rounded-sm" style={{ backgroundColor: colorScale(name) }} />
        {name}
      </span>
    ))}
  </div>
</div>
```

Note: The legend needs `uniqueShardNames` and `colorScale` available at render time. Compute these from the data outside the useEffect (they are stable per mount since data is called once). Store in useMemo if needed.

Import: `getDgraphShards`, `DgraphShard` from `@/data/dgraph-data`, chart shared utils, `cn`, `d3`.
  </action>
  <verify>Run `npx tsc --noEmit`. Verify file contains `scaleBand` (both outer and inner), `scaleOrdinal`, grouped bar rendering pattern, and tooltip.</verify>
  <done>ShardBarChart renders 3 groups of bars colored by shard name, Y axis formatted with formatNumber, tooltip on hover shows shard detail, legend displays all unique shard names with colors, responsive resize.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. QueryScatterPlot.tsx contains `d3.brush()`, scaleLinear, dots colored by query type
4. ShardBarChart.tsx contains double `scaleBand`, `scaleOrdinal`, grouped bar rendering
5. Both charts use `getChartColors()` for theme-aware rendering
6. Both charts use `createDebouncedResizeObserver` for responsive behavior
7. Both charts call `cleanupD3Svg` in useEffect cleanup
8. Both charts have `data-testid` attributes on their SVG elements
</verification>

<success_criteria>
- QueryScatterPlot renders 50 dots with GraphQL (blue) and DQL (emerald) colors
- Brush selection highlights selected dots and dims others
- Clearing brush resets all dots to original state
- Selected count displays when brush is active
- ShardBarChart renders 3 groups of colored bars with proper spacing
- Y axis uses formatNumber for large values (K suffix)
- Both charts have tooltips on hover
- Both charts have legends
- Both charts resize responsively
- Both charts clean up properly on unmount
</success_criteria>

<output>
After completion, create `.planning/phases/04-dgraph-monitoring/04-02-SUMMARY.md`
</output>
